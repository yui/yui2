
<html>
<head>
	<title>JavaScript Documentation - Event.js</title>
	<link href="stylesheet.css" rel="stylesheet" type="text/css" />
</head>

<body>

<div id="header">
	<h1>JavaScript Documentation</h1>
	<h3><a href="./index.html">Yui Event Utility</a></h3>

	<div class="breadcrumbs">
		
			
			
			
				<a href="./index.html">Yui Event Utility</a>
				&gt;
				<strong>Event.js</strong>
			
			
			
			
			
			
			
			
			
			
			
		
	</div>
</div>


<div id="body">
	
	
	<div class="nav">
		<div class="module resources">
			<ul class="content">
				<li><a href="overview-tree.html">Tree View</a></li>
				<li><a href="index-all.html">Element Index</a></li>
			</ul>
		</div>
		
		
			<div class="module">
				<h4><a href="./allclasses-noframe.html">Classes</a></h4>
				<ul class="content">
					
						<li>
							<a href="YAHOO.util.html">
								YAHOO.util</a>
						</li>
					
						<li>
							<a href="YAHOO.util.CustomEvent.html">
								YAHOO.util.CustomEvent</a>
						</li>
					
						<li>
							<a href="YAHOO.util.Event.html">
								YAHOO.util.Event</a>
						</li>
					
						<li>
							<a href="YAHOO.util.Subscriber.html">
								YAHOO.util.Subscriber</a>
						</li>
					
				</ul>
			</div>
		
		
		
			<div class="module">
				<h4><a href="./overview-summary.html">Files</a></h4>
				<ul class="content">		
					
						<li>
							<a href="overview-summary-CustomEvent.js.html">
								CustomEvent.js</a>
						</li>
					
						<li>
							<a href="overview-summary-Event.js.html">
								Event.js</a>
						</li>
					
				</ul>
			</div>
		
	</div>
	
	<div class="main">
			
		
		
			
			   <h2>Event.js</h2>
			
			
				
					
				
				
				
<div class="meta">
	
	
	
	
	
	
	
	
	
	
		
	
	
	
	
	
	
</div>

			
		
		
		
		
			<div class="quick-links">
				<strong>Quick Links:</strong>&nbsp;
				
					
						<a href="#classSummary">Class Summary</a> |
					
					
				
				
				
					<a href="#source">Source Code</a>
				
			</div>
		
			
				<div class="section class summaries">
					 <h3><a name="classSummary">Class Summary</a> <span class="top">[<a href="#top">top</a>]</span></h3>
			
				<div class="content">
					<table border="1" cellpadding="3" cellspacing="0">
						
						<tr>
							<td class="name">
								<a href="YAHOO.util.Event.html">YAHOO.util.Event</a>
							</td>
							<td class="overview">The event utility provides functions to add and remove event listeners,  event cleansing.</td>
						</tr>
						
					</table>
				</div>
			</div>
		
		
		
		
		
		
		
			<div class="section source">
				<h3><a name="source">Souce Code</a> <span class="top">[<a href="#top">top</a>]</span></h3>
				<pre class="sourceview"><span class="comment">/* Copyright (c) 2006 Yahoo! Inc. All rights reserved. */</span>
<span class="comment">
// Only load this library once.  If it is loaded a second time, existing</span>
<span class="comment">// events cannot be detached.</span>
<span class="reserved">if</span> (!YAHOO.util.Event) {

<span class="comment">/**
 * <span class="attrib">@class</span>
 * The event utility provides functions to add and remove event listeners,
 * event cleansing.  It also tries to automatically remove listeners it
 * registers during the unload event.
 * <span class="attrib">@constructor</span>
 */</span>
    YAHOO.util.Event = <span class="reserved">function</span>() {

        <span class="comment">/**
         * True after the onload event has fired
         * <span class="attrib">@type</span> boolean
         * <span class="attrib">@private</span>
         */</span>
        var loadComplete =  false;

        <span class="comment">/**
         * Cache of wrapped listeners
         * <span class="attrib">@type</span> array
         * <span class="attrib">@private</span>
         */</span>
        var listeners = [];

        <span class="comment">/**
         * Listeners that will be attached during the onload event
         * <span class="attrib">@type</span> array
         * <span class="attrib">@private</span>
         */</span>
        var delayedListeners = [];

        <span class="comment">/**
         * User-defined unload function that will be fired before all events
         * are detached
         * <span class="attrib">@type</span> array
         * <span class="attrib">@private</span>
         */</span>
        var unloadListeners = [];

        <span class="comment">/**
         * Cache of the custom events that have been defined.  Used for
         * automatic cleanup
         * <span class="attrib">@type</span> array
         * <span class="attrib">@private</span>
         */</span>
        var customEvents = [];

        <span class="comment">/**
         * Cache of DOM0 event handlers to work around issues with DOM2 events
         * in Safari
         * <span class="attrib">@private</span>
         */</span>
        var legacyEvents = [];

        <span class="comment">/**
         * Listener stack for DOM0 events
         * <span class="attrib">@private</span>
         */</span>
        var legacyHandlers = [];

        YAHOO.util.Event.<span class="reserved">prototype</span> = {

            <span class="comment">/**
             * Element to bind, int constant
             * <span class="attrib">@type</span> int
             */</span>
            EL: 0,

            <span class="comment">/**
             * Type of event, int constant
             * <span class="attrib">@type</span> int
             */</span>
            TYPE: 1,

            <span class="comment">/**
             * Function to execute, int constant
             * <span class="attrib">@type</span> int
             */</span>
            FN: 2,

            <span class="comment">/**
             * Function wrapped for scope correction and cleanup, int constant
             * <span class="attrib">@type</span> int
             */</span>
            WFN: 3,

            <span class="comment">/**
             * Object passed in by the user that will be returned as a 
             * parameter to the callback, int constant
             * <span class="attrib">@type</span> int
             */</span>
            SCOPE: 3,

            <span class="comment">/**
             * Adjusted scope, either the element we are registering the event
             * on or the custom object passed in by the listener, int constant
             * <span class="attrib">@type</span> int
             */</span>
            ADJ_SCOPE: 4,

            <span class="comment">/**
             * Safari detection is necessary to work around the preventDefault
             * bug that makes it so you can't cancel a href click from the 
             * handler.  There is not a capabilities check we can use here.
             * <span class="attrib">@private</span>
             */</span>
            isSafari: (navigator.userAgent.match(/safari/gi)),

            <span class="comment">/**
             * <span class="attrib">@private</span>
             * IE detection needed to properly calculate pageX and pageY.  
             * capabilities checking didn't seem to work because another 
             * browser that does not provide the properties have the values 
             * calculated in a different manner than IE.
             */</span>
            isIE: (!<span class="reserved">this</span>.isSafari &amp;&amp; navigator.userAgent.match(/msie/gi)),

            <span class="comment">/**
             * Appends an event handler
             *
             * <span class="attrib">@param</span> {Object}   el        The html element to assign the 
             *                             event to
             * <span class="attrib">@param</span> {String}   sType     The type of event to append
             * <span class="attrib">@param</span> {Function} fn        The method the event invokes
             * <span class="attrib">@param</span> {Object}   oScope    An arbitrary object that will be 
             *                             passed as a parameter to the handler
             * <span class="attrib">@param</span> {boolean}  bOverride If true, the obj passed in becomes
             *                             the execution scope of the listener
             * <span class="attrib">@return</span> {boolean} True if the action was successful or defered,
             *                        false if one or more of the elements 
             *                        could not have the event bound to it.
             */</span>
            addListener: <span class="reserved">function</span>(el, sType, fn, oScope, bOverride) {
<span class="comment">
                // The el argument can be an array of elements or element ids.</span>
                <span class="reserved">if</span> ( <span class="reserved">this</span>._isValidCollection(el)) {
                    var ok = true;
                    <span class="reserved">for</span> (var i=0; i&lt; el.length; ++i) {
                        ok = ( <span class="reserved">this</span>.on(el[i], 
                                       sType, 
                                       fn, 
                                       oScope, 
                                       bOverride) &amp;&amp; ok );
                    }
                    <span class="reserved">return</span> ok;

                } <span class="reserved">else</span> <span class="reserved">if</span> (typeof el == <span class="literal">"string"</span>) {
<span class="comment">                    // If the el argument is a string, we assume it is </span>
<span class="comment">                    // actually the id of the element.  If the page is loaded</span>
<span class="comment">                    // we convert el to the actual element, otherwise we </span>
<span class="comment">                    // defer attaching the event until onload event fires</span>
<span class="comment">
                    // check to see if we need to delay hooking up the event </span>
<span class="comment">                    // until after the page loads.</span>
                    <span class="reserved">if</span> (loadComplete) {
                        el = <span class="reserved">this</span>.getEl(el);
                    } <span class="reserved">else</span> {
<span class="comment">                        // defer adding the event until onload fires</span>
                        delayedListeners[delayedListeners.length] =
                            [el, sType, fn, oScope, bOverride];

                        <span class="reserved">return</span> true;
                    }
                }
<span class="comment">
                // Element should be an html element or an array if we get </span>
<span class="comment">                // here.</span>
                <span class="reserved">if</span> (!el) {
<span class="comment">                    // this.logger.debug("unable to attach event " + sType);</span>
                    <span class="reserved">return</span> false;
                }
<span class="comment">
                // we need to make sure we fire registered unload events </span>
<span class="comment">                // prior to automatically unhooking them.  So we hang on to </span>
<span class="comment">                // these instead of attaching them to the window and fire the</span>
<span class="comment">                // handles explicitly during our one unload event.</span>
                <span class="reserved">if</span> (<span class="literal">"unload"</span> == sType &amp;&amp; oScope !== <span class="reserved">this</span>) {
                    unloadListeners[unloadListeners.length] =
                            [el, sType, fn, oScope, bOverride];
                    <span class="reserved">return</span> true;
                }
<span class="comment">
                // this.logger.debug("Adding handler: " + el + ", " + sType);</span>
<span class="comment">
                // if the user chooses to override the scope, we use the custom</span>
<span class="comment">                // object passed in, otherwise the executing scope will be the</span>
<span class="comment">                // HTML element that the event is registered on</span>
                var scope = (bOverride) ? oScope : el;
<span class="comment">
                // wrap the function so we can return the oScope object when</span>
<span class="comment">                // the event fires;</span>
                var wrappedFn = <span class="reserved">function</span>(e) {
                        <span class="reserved">return</span> fn.call(scope, YAHOO.util.Event.getEvent(e), 
                                oScope);
                    };

                var li = [el, sType, fn, wrappedFn, scope];
                var index = listeners.length;
<span class="comment">                // cache the listener so we can try to automatically unload</span>
                listeners[index] = li;

                <span class="reserved">if</span> (<span class="reserved">this</span>.useLegacyEvent(el, sType)) {
                    var legacyIndex = <span class="reserved">this</span>.getLegacyIndex(el, sType);
                    <span class="reserved">if</span> (legacyIndex == -1) {

                        legacyIndex = legacyEvents.length;
<span class="comment">                        // cache the signature for the DOM0 event, and </span>
<span class="comment">                        // include the existing handler for the event, if any</span>
                        legacyEvents[legacyIndex] = 
                            [el, sType, el[<span class="literal">"on"</span> + sType]];
                        legacyHandlers[legacyIndex] = [];

                        el[<span class="literal">"on"</span> + sType] = 
                            <span class="reserved">function</span>(e) {
                                YAHOO.util.Event.fireLegacyEvent(
                                    YAHOO.util.Event.getEvent(e), legacyIndex);
                            };
                    }
<span class="comment">
                    // add a reference to the wrapped listener to our custom</span>
<span class="comment">                    // stack of events</span>
                    legacyHandlers[legacyIndex].push(index);
<span class="comment">
                // DOM2 Event model</span>
                } <span class="reserved">else</span> <span class="reserved">if</span> (el.addEventListener) {
<span class="comment">                    // this.logger.debug("adding DOM event: " + el.id + </span>
<span class="comment">                    // ", " + sType);</span>
                    el.addEventListener(sType, wrappedFn, false);
<span class="comment">                // Internet Explorer abstraction</span>
                } <span class="reserved">else</span> <span class="reserved">if</span> (el.attachEvent) {
                    el.attachEvent(<span class="literal">"on"</span> + sType, wrappedFn);
                }

                <span class="reserved">return</span> true;
                
            },

            <span class="comment">/**
             * Shorthand for YAHOO.util.Event.addListener
             * <span class="attrib">@type</span> function
             */</span>
<span class="comment">            // on: this.addListener,</span>

            <span class="comment">/**
             * When using legacy events, the handler is routed to this object
             * so we can fire our custom listener stack.
             * <span class="attrib">@private</span>
             */</span>
            fireLegacyEvent: <span class="reserved">function</span>(e, legacyIndex) {
<span class="comment">                // alert("fireLegacyEvent " + legacyIndex);</span>
                var ok = true;
<span class="comment">
                // var el = legacyEvents[YAHOO.util.Event.EL];</span>

                <span class="comment">/* this is not working because the property may get populated
                // fire the event we replaced, if it exists
                var origHandler = legacyEvents[2];
                alert(origHandler);
                if (origHandler &amp;&amp; origHandler.call) {
                    var ret = origHandler.call(el, e);
                    ok = (ret);
                }
                */</span>

                var le = legacyHandlers[legacyIndex];
                <span class="reserved">for</span> (i=0; i &lt; le.length; ++i) {
                    var index = le[i];
<span class="comment">                    // alert(index);</span>
                    <span class="reserved">if</span> (index) {
                        var li = listeners[index];
                        var scope = li[<span class="reserved">this</span>.ADJ_SCOPE];
                        var ret = li[<span class="reserved">this</span>.WFN].call(scope, e);
                        ok = (ok &amp;&amp; ret);
<span class="comment">                        // alert(ok);</span>
                    }
                }

                <span class="reserved">return</span> ok;
            },

            <span class="comment">/**
             * Returns the legacy event index that matches the supplied 
             * signature
             * <span class="attrib">@private</span>
             */</span>
            getLegacyIndex: <span class="reserved">function</span>(el, sType) {
                <span class="reserved">for</span> (var i=0; i &lt; legacyEvents.length; ++i) {
                    var le = legacyEvents[i];
                    <span class="reserved">if</span> (le &amp;&amp; le[0] == el &amp;&amp; le[1] == sType) {
                        <span class="reserved">return</span> i;
                    }
                }

                <span class="reserved">return</span> -1;
            },

            <span class="comment">/**
             * Logic that determines when we should automatically use legacy
             * events instead of DOM2 events.
             * <span class="attrib">@private</span>
             */</span>
            useLegacyEvent: <span class="reserved">function</span>(el, sType) {

                <span class="reserved">return</span> ( (!el.addEventListener &amp;&amp; !el.attachEvent) || 
                                (sType == <span class="literal">"click"</span> &amp;&amp; <span class="reserved">this</span>.isSafari) );
            },
                    
            <span class="comment">/**
             * Removes an event handler
             *
             * <span class="attrib">@param</span> {Object} el the html element or the id of the element to 
             * assign the event to.
             * <span class="attrib">@param</span> {String} sType the type of event to remove
             * <span class="attrib">@param</span> {Function} fn the method the event invokes
             * <span class="attrib">@return</span> {boolean} true if the unbind was successful, false 
             * otherwise
             */</span>
            removeListener: <span class="reserved">function</span>(el, sType, fn) {
<span class="comment">
                // The el argument can be a string</span>
                <span class="reserved">if</span> (typeof el == <span class="literal">"string"</span>) {
                    el = <span class="reserved">this</span>.getEl(el);
<span class="comment">                // The el argument can be an array of elements or element ids.</span>
                } <span class="reserved">else</span> <span class="reserved">if</span> ( <span class="reserved">this</span>._isValidCollection(el)) {
                    var ok = true;
                    <span class="reserved">for</span> (var i=0; i&lt; el.length; ++i) {
                        ok = ( <span class="reserved">this</span>.removeListener(el[i], sType, fn) &amp;&amp; ok );
                    }
                    <span class="reserved">return</span> ok;
                }

                var cacheItem = null;
                var index = <span class="reserved">this</span>._getCacheIndex(el, sType, fn);

                <span class="reserved">if</span> (index &gt;= 0) {
                    cacheItem = listeners[index];
                }

                <span class="reserved">if</span> (!el || !cacheItem) {
<span class="comment">                    // this.logger.debug("cached listener not found");</span>
                    <span class="reserved">return</span> false;
                }
<span class="comment">
                // this.logger.debug("Removing handler: " + el + ", " + sType);</span>

                <span class="reserved">if</span> (el.removeEventListener) {
                    el.removeEventListener(sType, cacheItem[<span class="reserved">this</span>.WFN], false);
<span class="comment">                    // alert("adsf");</span>
                } <span class="reserved">else</span> <span class="reserved">if</span> (el.detachEvent) {
                    el.detachEvent(<span class="literal">"on"</span> + sType, cacheItem[<span class="reserved">this</span>.WFN]);
                }
<span class="comment">
                // removed the wrapped handler</span>
                delete listeners[index][<span class="reserved">this</span>.WFN];
                delete listeners[index][<span class="reserved">this</span>.FN];
                delete listeners[index];

                <span class="reserved">return</span> true;

            },

            <span class="comment">/**
             * Returns the event's target element
             * <span class="attrib">@param</span> {Event} ev the event
             * <span class="attrib">@param</span> {boolean} resolveTextNode when set to true the target's
             *                  parent will be returned if the target is a 
             *                  text node
             * <span class="attrib">@return</span> {HTMLElement} the event's target
             */</span>
            getTarget: <span class="reserved">function</span>(ev, resolveTextNode) {
                var t = ev.target || ev.srcElement;

                <span class="reserved">if</span> (resolveTextNode &amp;&amp; t &amp;&amp; <span class="literal">"#text"</span> == t.nodeName) {
<span class="comment">                    // this.logger.debug("target is text node, returning </span>
<span class="comment">                    // parent");</span>
                    <span class="reserved">return</span> t.parentNode;
                } <span class="reserved">else</span> {
                    <span class="reserved">return</span> t;
                }
            },

            <span class="comment">/**
             * Returns the event's pageX
             * <span class="attrib">@param</span> {Event} ev the event
             * <span class="attrib">@return</span> {int} the event's pageX
             */</span>
            getPageX: <span class="reserved">function</span>(ev) {
                var x = ev.pageX;
                <span class="reserved">if</span> (!x &amp;&amp; 0 !== x) {
                    x = ev.clientX || 0;

                    <span class="reserved">if</span> ( <span class="reserved">this</span>.isIE ) {
                        x += <span class="reserved">this</span>._getScrollLeft();
                    }
                }

                <span class="reserved">return</span> x;
            },

            <span class="comment">/**
             * Returns the event's pageY
             * <span class="attrib">@param</span> {Event} ev the event
             * <span class="attrib">@return</span> {int} the event's pageY
             */</span>
            getPageY: <span class="reserved">function</span>(ev) {
                var y = ev.pageY;
                <span class="reserved">if</span> (!y &amp;&amp; 0 !== y) {
                    y = ev.clientY || 0;

                    <span class="reserved">if</span> ( <span class="reserved">this</span>.isIE ) {
                        y += <span class="reserved">this</span>._getScrollTop();
                    }
                }


                <span class="reserved">return</span> y;
            },

            <span class="comment">/**
             * Returns the event's related target 
             * <span class="attrib">@param</span> {Event} ev the event
             * <span class="attrib">@return</span> {HTMLElement} the event's relatedTarget
             */</span>
            getRelatedTarget: <span class="reserved">function</span>(ev) {
                var t = ev.relatedTarget;
                <span class="reserved">if</span> (!t) {
                    <span class="reserved">if</span> (ev.type == <span class="literal">"mouseout"</span>) {
                        t = ev.toElement;
                    } <span class="reserved">else</span> <span class="reserved">if</span> (ev.type == <span class="literal">"mouseover"</span>) {
                        t = ev.fromElement;
                    }
                }

                <span class="reserved">return</span> t;
            },

            <span class="comment">/**
             * Returns the time of the event.  If the time is not included, the
             * event is modified using the current time.
             * <span class="attrib">@param</span> {Event} ev the event
             * <span class="attrib">@return</span> {Date} the time of the event
             */</span>
            getTime: <span class="reserved">function</span>(ev) {
                <span class="reserved">if</span> (!ev.time) {
                    var t = new Date().getTime();
                    try {
                        ev.time = t;
                    } catch(e) { 
<span class="comment">                        // can't set the time property  </span>
                        <span class="reserved">return</span> t;
                    }
                }

                <span class="reserved">return</span> ev.time;
            },

            <span class="comment">/**
             * Convenience method for stopPropagation + preventDefault
             * <span class="attrib">@param</span> {Event} ev the event
             */</span>
            stopEvent: <span class="reserved">function</span>(ev) {
                <span class="reserved">this</span>.stopPropagation(ev);
                <span class="reserved">this</span>.preventDefault(ev);
            },

            <span class="comment">/**
             * Stops event propagation
             * <span class="attrib">@param</span> {Event} ev the event
             */</span>
            stopPropagation: <span class="reserved">function</span>(ev) {
                <span class="reserved">if</span> (ev.stopPropagation) {
                    ev.stopPropagation();
                } <span class="reserved">else</span> {
                    ev.cancelBubble = true;
                }
            },

            <span class="comment">/**
             * Prevents the default behavior of the event
             * <span class="attrib">@param</span> {Event} ev the event
             */</span>
            preventDefault: <span class="reserved">function</span>(ev) {
                <span class="reserved">if</span> (ev.preventDefault) {
                    ev.preventDefault();
                } <span class="reserved">else</span> {
                    ev.returnValue = false;
                }
            },
             
            <span class="comment">/**
             * Finds the event in the window object, the caller's arguments, or
             * in the arguments of another method in the callstack.  This is
             * executed automatically for events registered through the event
             * manager, so the implementer should not normally need to execute
             * this function at all.
             * <span class="attrib">@param</span> {Event} the event parameter from the handler
             * <span class="attrib">@return</span> {Event} the event 
             */</span>
            getEvent: <span class="reserved">function</span>(e) {
                var ev = e || window.event;

                <span class="reserved">if</span> (!ev) {
                    var c = <span class="reserved">this</span>.getEvent.caller;
                    <span class="reserved">while</span> (c) {
                        ev = c.arguments[0];
                        <span class="reserved">if</span> (ev &amp;&amp; Event == ev.constructor) {
                            break;
                        }
                        c = c.caller;
                    }
                }

                <span class="reserved">return</span> ev;
            },

            <span class="comment">/**
             * Returns the charcode for an event
             * <span class="attrib">@param</span> {Event} ev the event
             * <span class="attrib">@return</span> {int} the event's charCode
             */</span>
            getCharCode: <span class="reserved">function</span>(ev) {
                <span class="reserved">return</span> ev.charCode || (ev.type == <span class="literal">"keypress"</span>) ? ev.keyCode : 0;
            },

            <span class="comment">/**
             * <span class="attrib">@private</span>
             * Locating the saved event handler data by function ref
             */</span>
            _getCacheIndex: <span class="reserved">function</span>(el, sType, fn) {
                <span class="reserved">for</span> (var i=0; i&lt; listeners.length; ++i) {
                    var li = listeners[i];
                    <span class="reserved">if</span> ( li                 &amp;&amp; 
                         li[<span class="reserved">this</span>.FN] == fn  &amp;&amp; 
                         li[<span class="reserved">this</span>.EL] == el  &amp;&amp; 
                         li[<span class="reserved">this</span>.TYPE] == sType ) {
                        <span class="reserved">return</span> i;
                    }
                }

                <span class="reserved">return</span> -1;
            },

            <span class="comment">/**
             * We want to be able to use getElementsByTagName as a collection
             * to attach a group of events to.  Unfortunately, different 
             * browsers return different types of collections.  This function
             * tests to determine if the object is array-like.  It will also 
             * fail if the object is an array, but is empty.
             * <span class="attrib">@param</span> o the object to test
             * <span class="attrib">@return</span> {boolean} true if the object is array-like and populated
             * <span class="attrib">@private</span>
             */</span>
            _isValidCollection: <span class="reserved">function</span>(o) {
<span class="comment">                // alert(o.constructor.toString())</span>
<span class="comment">                // alert(typeof o)</span>

                <span class="reserved">return</span> ( o                    &amp;&amp; // o is something
                         o.length             &amp;&amp; // o is indexed
                         typeof o != <span class="literal">"string"</span> &amp;&amp; // o is not a string
                         !o.tagName           &amp;&amp; // o is not an HTML element
                         !o.alert             &amp;&amp; // o is not a window
                         typeof o[0] != <span class="literal">"undefined"</span> );

            },

            <span class="comment">/**
             * <span class="attrib">@private</span>
             * DOM element cache
             */</span>
            elCache: {},

            <span class="comment">/**
             * We cache elements bound by id because when the unload event 
             * fires, we can no longer use document.getElementById
             * <span class="attrib">@private</span>
             */</span>
            getEl: <span class="reserved">function</span>(id) {
                <span class="comment">/*
                // this is a problem when replaced via document.getElementById
                if (! this.elCache[id]) {
                    try {
                        var el = document.getElementById(id);
                        if (el) {
                            this.elCache[id] = el;
                        }
                    } catch (er) {
                        // this.logger.debug("document obj not currently 
                        // available");
                    }
                }
                return this.elCache[id];
                */</span>

                <span class="reserved">return</span> document.getElementById(id);
            },

            <span class="comment">/**
             * Clears the element cache
             */</span>
            clearCache: <span class="reserved">function</span>() {
                <span class="reserved">for</span> (i in <span class="reserved">this</span>.elCache) {
                    delete <span class="reserved">this</span>.elCache[i];
                }
            },

            <span class="comment">/**
             * Called by CustomEvent instances to provide a handle to the 
             * event * that can be removed later on.  Should be package 
             * protected.
             * <span class="attrib">@private</span>
             */</span>
            regCE: <span class="reserved">function</span>(ce) {
                customEvents.push(ce);
            },

            <span class="comment">/**
             * <span class="attrib">@private</span>
             * hook up any deferred listeners
             */</span>
            _load: <span class="reserved">function</span>(e) {
<span class="comment">                // me.logger = new ygLogger("pe.Event");</span>
                loadComplete = true;
            },

            <span class="comment">/**
             * Polling function that runs before the onload event fires, 
             * attempting * to attach to DOM Nodes as soon as they are 
             * available
             * <span class="attrib">@private</span>
             */</span>
            _tryPreloadAttach: <span class="reserved">function</span>() {
<span class="comment">                // this.logger.debug("tryPreloadAttach");</span>
<span class="comment">
                // keep trying until after the page is loaded.  We need to </span>
<span class="comment">                // check the page load state prior to trying to bind the </span>
<span class="comment">                // elements so that we can be certain all elements have been </span>
<span class="comment">                // tested appropriately</span>
                var tryAgain = !loadComplete;

                <span class="reserved">for</span> (var i=0; i &lt; delayedListeners.length; ++i) {
                    var d = delayedListeners[i];
<span class="comment">                    // There may be a race condition here, so we need to </span>
<span class="comment">                    // verify the array element is usable.</span>
                    <span class="reserved">if</span> (d) {
<span class="comment">
                        // el will be null if document.getElementById did not</span>
<span class="comment">                        // work</span>
                        var el = <span class="reserved">this</span>.getEl(d[<span class="reserved">this</span>.EL]);

                        <span class="reserved">if</span> (el) {
<span class="comment">                            // this.logger.debug("attaching: " + d[this.EL]);</span>
                            <span class="reserved">this</span>.on(el, d[<span class="reserved">this</span>.TYPE], d[<span class="reserved">this</span>.FN], 
                                    d[<span class="reserved">this</span>.SCOPE], d[<span class="reserved">this</span>.ADJ_SCOPE]);
                            delete delayedListeners[i];
                        }
                    }
                }

                <span class="reserved">if</span> (tryAgain) {
                    setTimeout(<span class="literal">"YAHOO.util.Event._tryPreloadAttach()"</span>, 50);
                }
            },

            <span class="comment">/**
             * Removes all listeners registered by pe.event.  Called 
             * automatically during the unload event.
             * <span class="attrib">@private</span>
             */</span>
            _unload: <span class="reserved">function</span>(e, me) {
                <span class="reserved">for</span> (var i=0; i &lt; unloadListeners.length; ++i) {
                    var l = unloadListeners[i];
                    <span class="reserved">if</span> (l) {
                        var scope = (l[<span class="reserved">this</span>.ADJ_SCOPE]) ? l[<span class="reserved">this</span>.SCOPE]: window;
                        l[<span class="reserved">this</span>.FN].call(scope, <span class="reserved">this</span>.getEvent(e), l[<span class="reserved">this</span>.SCOPE] );
                    }
                }

                <span class="reserved">if</span> (listeners &amp;&amp; listeners.length &gt; 0) {
                    <span class="reserved">for</span> (i = 0; i &lt; listeners.length; ++i) {
                        l = listeners[i];
                        <span class="reserved">if</span> (l) {
                            <span class="reserved">this</span>.removeListener(l[<span class="reserved">this</span>.EL], l[<span class="reserved">this</span>.TYPE], 
                                    l[<span class="reserved">this</span>.FN]);
                        }
                    }

                    <span class="reserved">this</span>.clearCache();
                }

                <span class="reserved">for</span> (i = 0; i &lt; customEvents.length; ++i) {
                    customEvents[i].unsubscribeAll();
                    delete customEvents[i];
                }

                <span class="reserved">for</span> (i = 0; i &lt; legacyEvents.length; ++i) {
<span class="comment">                    // dereference the element</span>
                    delete legacyEvents[i][0];
<span class="comment">                    // delete the array item</span>
                    delete legacyEvents[i];
                }
            },

            <span class="comment">/**
             * Returns scrollLeft
             * <span class="attrib">@private</span>
             */</span>
            _getScrollLeft: <span class="reserved">function</span>() {
                <span class="reserved">return</span> <span class="reserved">this</span>._getScroll()[1];
            },

            <span class="comment">/**
             * Returns scrollTop
             * <span class="attrib">@private</span>
             */</span>
            _getScrollTop: <span class="reserved">function</span>() {
                <span class="reserved">return</span> <span class="reserved">this</span>._getScroll()[0];
            },

            <span class="comment">/**
             * Returns the scrollTop and scrollLeft.  Used to calculate the 
             * pageX and pageY in Internet Explorer
             * <span class="attrib">@private</span>
             */</span>
            _getScroll: <span class="reserved">function</span>() {
                var dd = document.documentElement; db = document.body;
                <span class="reserved">if</span> (dd &amp;&amp; dd.scrollTop) {
                    <span class="reserved">return</span> [dd.scrollTop, dd.scrollLeft];
                } <span class="reserved">else</span> <span class="reserved">if</span> (db) {
                    <span class="reserved">return</span> [db.scrollTop, db.scrollLeft];
                } <span class="reserved">else</span> {
                    <span class="reserved">return</span> [0, 0];
                }
            }
        };
    } ();

    <span class="comment">/**
     * <span class="attrib">@private</span>
     */</span>
    YAHOO.util.Event.on = YAHOO.util.Event.addListener;

    <span class="reserved">if</span> (document &amp;&amp; document.body) {
        YAHOO.util.Event._load();
    } <span class="reserved">else</span> {
        YAHOO.util.Event.on(window, <span class="literal">"load"</span>, YAHOO.util.Event._load, 
                YAHOO.util.Event, true);
    }

    YAHOO.util.Event.on(window, <span class="literal">"unload"</span>, YAHOO.util.Event._unload, 
                YAHOO.util.Event, true);

    YAHOO.util.Event._tryPreloadAttach();

}

</pre>
			</div>
		
	</div>
</div>


<div id="footer">
	<hr />
	Copyright &copy; 2004 - 2005 Yahoo! Inc. All rights reserved.
	<br />
	Yahoo! Confidential.
	<br /><br />
	Documentation generated by <a href="http://jsdoc.sourceforge.net/">JSDoc</a>
</div>


</body>
</html>
