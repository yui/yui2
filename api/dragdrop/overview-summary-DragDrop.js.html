
<html>
<head>
	<title>API: Drag and Drop overview-summary-DragDrop.js.html (YUI Library)</title>
	<link href="stylesheet.css" rel="stylesheet" type="text/css" />
</head>

<body>

<div id="header">
	<h1>Yahoo! UI Library</h1>
	<h3><a href="./index.html">Drag and Drop</a></h3>

	<div class="breadcrumbs">
		
			
			
			
				<a href="./index.html">Drag and Drop</a>
				&gt;
				<strong>DragDrop.js</strong>
			
			
			
			
			
			
			
			
			
			
			
		
	</div>
</div>


<div id="body">
	
	
	<div class="nav">
		<div class="module resources">
			<ul class="content">
				<li><a href="overview-tree.html">Tree View</a></li>
				<li><a href="index-all.html">Element Index</a></li>
			</ul>
		</div>
		
		
			<div class="module">
				<h4><a href="./allclasses-noframe.html">Classes</a></h4>
				<ul class="content">
					
						<li>
							<a href="YAHOO.util.html">
								YAHOO.util</a>
						</li>
					
						<li>
							<a href="YAHOO.util.DD.html">
								YAHOO.util.DD</a>
						</li>
					
						<li>
							<a href="YAHOO.util.DDProxy.html">
								YAHOO.util.DDProxy</a>
						</li>
					
						<li>
							<a href="YAHOO.util.DDTarget.html">
								YAHOO.util.DDTarget</a>
						</li>
					
						<li>
							<a href="YAHOO.util.DragDrop.html">
								YAHOO.util.DragDrop</a>
						</li>
					
						<li>
							<a href="YAHOO.util.DragDropMgr.html">
								YAHOO.util.DragDropMgr</a>
						</li>
					
				</ul>
			</div>
		
		
		
			<div class="module">
				<h4><a href="./overview-summary.html">Files</a></h4>
				<ul class="content">		
					
						<li>
							<a href="overview-summary-DD.js.html">
								DD.js</a>
						</li>
					
						<li>
							<a href="overview-summary-DDProxy.js.html">
								DDProxy.js</a>
						</li>
					
						<li>
							<a href="overview-summary-DDTarget.js.html">
								DDTarget.js</a>
						</li>
					
						<li>
							<a href="overview-summary-DragDrop.js.html">
								DragDrop.js</a>
						</li>
					
						<li>
							<a href="overview-summary-DragDropMgr.js.html">
								DragDropMgr.js</a>
						</li>
					
				</ul>
			</div>
		
	</div>
	
	<div class="main">
			
		
		
			
			   <h2>DragDrop.js</h2>
			
			
				
					
				
				
				
<div class="meta">
	
	
	
	
	
	
	
	
	
	
		
	
	
	
	
	
	
</div>

			
		
		
		
		
			<div class="quick-links">
				<strong>Quick Links:</strong>&nbsp;
				
					
					
					
				
				
				
					<a href="#source">Source Code</a>
				
			</div>
		
			
				<div class="section class summaries">
			
				<div class="content">
						
						

				</div>
			</div>
		
		
		
		
		
		
		
			<div class="section source">


<style>
strong.alert {color:red;}
</style>
<p><strong class="alert">Note:</strong> Code presented here has been
modified from the original source to aid in processing and
presentation.  This is <strong>NOT</strong> functional code.  To review this
component's literal, functional source, please refer to its
JavaScript files as provided in <a href="http://sourceforge.net/
projects/yui/">the downloadable YUI Library distribution</a>.</p>

				<h3><a name="source">Source Code</a> <span class="top">[<a href="#top">top</a>]</span></h3>
				<pre class="sourceview"><span class="comment">/**
 * Defines the interface and base operation of items that that can be 
 * dragged or can be drop targets.  It was designed to be extended, overriding
 * the event handlers for startDrag, onDrag, onDragOver, onDragOut.
 * Up to three html elements can be associated with a DragDrop instance:
 * &lt;ul&gt;
 * &lt;li&gt;linked element: the element that is passed into the constructor.
 * This is the element which defines the boundaries for interaction with 
 * other DragDrop objects.&lt;/li&gt;
 * &lt;li&gt;handle element(s): The drag operation only occurs if the element that 
 * was clicked matches a handle element.  By default this is the linked 
 * element, but there are times that you will want only a portion of the 
 * linked element to initiate the drag operation, and the setHandleElId() 
 * method provides a way to define this.&lt;/li&gt;
 * &lt;li&gt;drag element: this represents an the element that would be moved along
 * with the cursor during a drag operation.  By default, this is the linked
 * element itself as in &lt;a href="YAHOO.util.DD.html#"&gt;YAHOO.util.DD&lt;/a&gt;.  setDragElId() lets you define
 * a separate element that would be moved, as in &lt;a href="YAHOO.util.DDProxy.html#"&gt;YAHOO.util.DDProxy&lt;/a&gt;
 * &lt;/li&gt;
 * &lt;/ul&gt;
 * This class should not be instantiated until the onload event to ensure that
 * the associated elements are available.
 * The following would define a DragDrop obj that would interact with any 
 * other * DragDrop obj in the "group1" group:
 * &lt;pre&gt;
 *  dd = new YAHOO.util.DragDrop("div1", "group1");
 * &lt;/pre&gt;
 * Since none of the event handlers have been implemented, nothing would 
 * actually happen if you were to run the code above.  Normally you would 
 * override this class or one of the default implementations, but you can 
 * also override the methods you want on an instance of the class...
 * &lt;pre&gt;
 *  dd.onDragDrop = function(e, id) {
 *   alert("dd was dropped on " + id);
 *  }
 * &lt;/pre&gt;
 * <span class="attrib">@constructor</span>
 * <span class="attrib">@param</span> {String} id of the element that is linked to this instance
 * <span class="attrib">@param</span> {String} sGroup the group of related DragDrop objects
 * <span class="attrib">@param</span> {object} config an object containing configurable attributes
 *                Valid properties for DragDrop: 
 *                    padding, isTarget, maintainOffset, primaryButtonOnly
 */</span>
YAHOO.util.DragDrop = <span class="reserved">function</span>(id, sGroup, config) {
    <span class="reserved">if</span> (id) {
        <span class="reserved">this</span>.init(id, sGroup, config); 
    }
};

YAHOO.util.DragDrop.<span class="reserved">prototype</span> = {

    <span class="comment">/**
     * The id of the element associated with this object.  This is what we 
     * refer to as the "linked element" because the size and position of 
     * this element is used to determine when the drag and drop objects have 
     * interacted.
     *
     * <span class="attrib">@type</span> String
     */</span>
    id: null,

    <span class="comment">/**
     * Configuration attributes passed into the constructor
     * <span class="attrib">@type</span> object
     */</span>
    config: null,


    <span class="comment">/**
     * An associative array of HTML tags that will be ignored if clicked.
     * <span class="attrib">@type</span> {string: string}
     */</span>
    invalidHandleTypes: null, 

    <span class="comment">/**
     * An associative array of ids for elements that will be ignored if clicked
     * <span class="attrib">@type</span> {string: string}
     */</span>
    invalidHandleIds: null, 

    <span class="comment">/**
     * An indexted array of css class names for elements that will be ignored
     * if clicked.
     * <span class="attrib">@type</span> string[]
     */</span>
    invalidHandleClasses: null, 

    <span class="comment">/**
     * The group defines a logical collection of DragDrop objects that are 
     * related.  Instances only get events when interacting with other 
     * DragDrop object in the same group.  This lets us define multiple 
     * groups using a single DragDrop subclass if we want.
     * <span class="attrib">@type</span> {string: string}
     */</span>
    groups: null,


    <span class="comment">/**
     * Lock this instance
     */</span>
    lock: <span class="reserved">function</span>() { <span class="reserved">this</span>.locked = true; },

    <span class="comment">/**
     * Unlock this instace
     */</span>
    unlock: <span class="reserved">function</span>() { <span class="reserved">this</span>.locked = false; },

    <span class="comment">/**
     * By default, all insances can be a drop target.  This can be disabled by
     * setting isTarget to false.
     *
     * <span class="attrib">@type</span> boolean
     */</span>
    isTarget: true,

    <span class="comment">/**
     * The padding configured for this drag and drop object for calculating
     * the drop zone intersection with this object.
     * <span class="attrib">@type</span> int[]
     */</span>
    padding: null,

    <span class="comment">/**
     * Maintain offsets when we resetconstraints.  Used to maintain the 
     * slider thumb value, and this needs to be fixed.
     * <span class="attrib">@type</span> boolean
     */</span>
    maintainOffset: false,

    <span class="comment">/**
     * Array of pixel locations the element will snap to if we specified a 
     * horizontal graduation/interval.  This array is generated automatically
     * when you define a tick interval.
     * <span class="attrib">@type</span> int[]
     */</span>
    xTicks: null,

    <span class="comment">/**
     * Array of pixel locations the element will snap to if we specified a 
     * vertical graduation/interval.  This array is generated automatically 
     * when you define a tick interval.
     * <span class="attrib">@type</span> int[]
     */</span>
    yTicks: null,

    <span class="comment">/**
     * By default the drag and drop instance will only respond to the primary
     * button click (left button for a right-handed mouse).  Set to true to
     * allow drag and drop to start with any mouse click that is propogated
     * by the browser
     * <span class="attrib">@type</span> boolean
     */</span>
    primaryButtonOnly: true,

    <span class="comment">/**
     * The availabe property is false until the linked dom element is accessible.
     * <span class="attrib">@type</span> boolean
     */</span>
    available: false,

    <span class="comment">/**
     * Abstract method called after a drag/drop object is clicked
     * and the drag or mousedown time thresholds have beeen met.
     *
     * <span class="attrib">@param</span> {int} X click location
     * <span class="attrib">@param</span> {int} Y click location
     */</span>
    startDrag: <span class="reserved">function</span>(x, y) { <span class="comment">/* override this */</span> },
    <span class="comment">/**
     * Abstract method called during the onMouseMove event while dragging an 
     * object.
     *
     * <span class="attrib">@param</span> {Event} e
     */</span>
    onDrag: <span class="reserved">function</span>(e) { <span class="comment">/* override this */</span> },

    <span class="comment">/**
     * Abstract method called when this element fist begins hovering over 
     * another DragDrop obj
     *
     * <span class="attrib">@param</span> {Event} e
     * <span class="attrib">@param</span> {String || YAHOO.util.DragDrop[]} id In POINT mode, the element
     * id this is hovering over.  In INTERSECT mode, an array of one or more 
     * dragdrop items being hovered over.
     */</span>
    onDragEnter: <span class="reserved">function</span>(e, id) { <span class="comment">/* override this */</span> },
    <span class="comment">/**
     * Abstract method called when this element is hovering over another 
     * DragDrop obj
     *
     * <span class="attrib">@param</span> {Event} e
     * <span class="attrib">@param</span> {String || YAHOO.util.DragDrop[]} id In POINT mode, the element
     * id this is hovering over.  In INTERSECT mode, an array of dd items 
     * being hovered over.
     */</span>
    onDragOver: <span class="reserved">function</span>(e, id) { <span class="comment">/* override this */</span> },
    <span class="comment">/**
     * Abstract method called when we are no longer hovering over an element
     *
     * <span class="attrib">@param</span> {Event} e
     * <span class="attrib">@param</span> {String || YAHOO.util.DragDrop[]} id In POINT mode, the element
     * id this was hovering over.  In INTERSECT mode, an array of dd items 
     * that the mouse is no longer over.
     */</span>
    onDragOut: <span class="reserved">function</span>(e, id) { <span class="comment">/* override this */</span> },
    <span class="comment">/**
     * Abstract method called when this item is dropped on another DragDrop 
     * obj
     *
     * <span class="attrib">@param</span> {Event} e
     * <span class="attrib">@param</span> {String || YAHOO.util.DragDrop[]} id In POINT mode, the element
     * id this was dropped on.  In INTERSECT mode, an array of dd items this 
     * was dropped on.
     */</span>
    onDragDrop: <span class="reserved">function</span>(e, id) { <span class="comment">/* override this */</span> },
    <span class="comment">/**
     * Fired when we are done dragging the object
     *
     * <span class="attrib">@param</span> {Event} e
     */</span>
    endDrag: <span class="reserved">function</span>(e) { <span class="comment">/* override this */</span> },
    <span class="comment">/**
     * Event handler that fires when a drag/drop obj gets a mousedown
     * <span class="attrib">@param</span> {Event} e
     */</span>
    onMouseDown: <span class="reserved">function</span>(e) { <span class="comment">/* override this */</span> },

    <span class="comment">/**
     * Event handler that fires when a drag/drop obj gets a mouseup
     * <span class="attrib">@param</span> {Event} e
     */</span>
    onMouseUp: <span class="reserved">function</span>(e) { <span class="comment">/* override this */</span> },
   
    <span class="comment">/**
     * Override the onAvailable method to do what is needed after the initial
     * position was determined.
     */</span>
    onAvailable: <span class="reserved">function</span> () { 
        <span class="reserved">this</span>.logger.log(<span class="literal">"onAvailable (base)"</span>); 
    },

    <span class="comment">/**
     * Returns a reference to the linked element
     *
     * <span class="attrib">@return</span> {HTMLElement} the html element 
     */</span>
    getEl: <span class="reserved">function</span>() { 
        <span class="reserved">if</span> (!<span class="reserved">this</span>._domRef) {
            <span class="reserved">this</span>._domRef = YAHOO.util.Dom.get(<span class="reserved">this</span>.id); 
        }

        <span class="reserved">return</span> <span class="reserved">this</span>._domRef;
    },

    <span class="comment">/**
     * Returns a reference to the actual element to drag.  By default this is
     * the same as the html element, but it can be assigned to another 
     * element. An example of this can be found in YAHOO.util.DDProxy
     *
     * <span class="attrib">@return</span> {HTMLElement} the html element 
     */</span>
    getDragEl: <span class="reserved">function</span>() {
        <span class="reserved">return</span> YAHOO.util.Dom.get(<span class="reserved">this</span>.dragElId);
    },

    <span class="comment">/**
     * Sets up the DragDrop object.  Must be called in the constructor of any
     * YAHOO.util.DragDrop subclass
     *
     * <span class="attrib">@param</span> id the id of the linked element
     * <span class="attrib">@param</span> {String} sGroup the group of related items
     * <span class="attrib">@param</span> {object} config configuration attributes
     */</span>
    init: <span class="reserved">function</span>(id, sGroup, config) {
        <span class="reserved">this</span>.initTarget(id, sGroup, config);
        YAHOO.util.Event.addListener(<span class="reserved">this</span>.id, <span class="literal">"mousedown"</span>, 
                                          <span class="reserved">this</span>.handleMouseDown, <span class="reserved">this</span>, true);
    },

    <span class="comment">/**
     * Initializes Targeting functionality only... the object does not
     * get a mousedown handler.
     *
     * <span class="attrib">@param</span> id the id of the linked element
     * <span class="attrib">@param</span> {String} sGroup the group of related items
     * <span class="attrib">@param</span> {object} config configuration attributes
     */</span>
    initTarget: <span class="reserved">function</span>(id, sGroup, config) {
<span class="comment">
        // configuration attributes </span>
        <span class="reserved">this</span>.config = config || {};
<span class="comment">
        // create a local reference to the drag and drop manager</span>
        <span class="reserved">this</span>.DDM = YAHOO.util.DDM;
<span class="comment">        // initialize the groups array</span>
        <span class="reserved">this</span>.groups = {};
<span class="comment">
        // set the id</span>
        <span class="reserved">this</span>.id = id;
<span class="comment">
        // add to an interaction group</span>
        <span class="reserved">this</span>.addToGroup((sGroup) ? sGroup : <span class="literal">"default"</span>);
<span class="comment">
        // We don't want to register this as the handle with the manager</span>
<span class="comment">        // so we just set the id rather than calling the setter.</span>
        <span class="reserved">this</span>.handleElId = id;

        YAHOO.util.Event.onAvailable(id, <span class="reserved">this</span>.handleOnAvailable, <span class="reserved">this</span>, true);
<span class="comment">
        // create a logger instance</span>
        <span class="reserved">this</span>.logger = (YAHOO.widget.LogWriter) ? 
                new YAHOO.widget.LogWriter(<span class="reserved">this</span>.toString()) : YAHOO;
<span class="comment">
        // the linked element is the element that gets dragged by default</span>
        <span class="reserved">this</span>.setDragElId(id); 
<span class="comment">
        // by default, clicked anchors will not start drag operations. </span>
<span class="comment">        // <span class="attrib">@TODO</span> what else should be here?  Probably form fields.</span>
        <span class="reserved">this</span>.invalidHandleTypes = { A: <span class="literal">"A"</span> };
        <span class="reserved">this</span>.invalidHandleIds = {};
        <span class="reserved">this</span>.invalidHandleClasses = [];

        <span class="reserved">this</span>.applyConfig();
    },

    <span class="comment">/**
     * Applies the configuration parameters that were passed into the constructor.
     * This is supposed to happen at each level through the inheritance chain.  So
     * a DDProxy implentation will execute apply config on DDProxy, DD, and 
     * DragDrop in order to get all of the parameters that are available in
     * each object.
     */</span>
    applyConfig: <span class="reserved">function</span>() {
<span class="comment">
        // configurable properties: </span>
<span class="comment">        //    padding, isTarget, maintainOffset, primaryButtonOnly</span>
        <span class="reserved">this</span>.padding           = <span class="reserved">this</span>.config.padding || [0, 0, 0, 0];
        <span class="reserved">this</span>.isTarget          = (<span class="reserved">this</span>.config.isTarget !== false);
        <span class="reserved">this</span>.maintainOffset    = (<span class="reserved">this</span>.config.maintainOffset);
        <span class="reserved">this</span>.primaryButtonOnly = (<span class="reserved">this</span>.config.primaryButtonOnly !== false);

    },

     <span class="comment">/**
     * Configures the padding for the target zone in px.  Effectively expands
     * (or reduces) the virtual object size for targeting calculations.  
     * Supports css-style shorthand; if only one parameter is passed, all sides
     * will have that padding, and if only two are passed, the top and bottom
     * will have the first param, the left and right the second.
     * <span class="attrib">@param</span> {int} iTop    Top pad
     * <span class="attrib">@param</span> {int} iRight  Right pad
     * <span class="attrib">@param</span> {int} iBot    Bot pad
     * <span class="attrib">@param</span> {int} iLeft   Left pad
     */</span>
    setPadding: <span class="reserved">function</span>(iTop, iRight, iBot, iLeft) {
<span class="comment">        // this.padding = [iLeft, iRight, iTop, iBot];</span>
        <span class="reserved">if</span> (!iRight &amp;&amp; 0 !== iRight) {
            <span class="reserved">this</span>.padding = [iTop, iTop, iTop, iTop];
        } <span class="reserved">else</span> <span class="reserved">if</span> (!iBot &amp;&amp; 0 !== iBot) {
            <span class="reserved">this</span>.padding = [iTop, iRight, iTop, iRight];
        } <span class="reserved">else</span> {
            <span class="reserved">this</span>.padding = [iTop, iRight, iBot, iLeft];
        }
    },

    <span class="comment">/**
     * Stores the initial placement of the dd element
     */</span>
    setInitPosition: <span class="reserved">function</span>(diffX, diffY) {
        var el = <span class="reserved">this</span>.getEl();

        <span class="reserved">if</span> (!<span class="reserved">this</span>.DDM.verifyEl(el)) {
            <span class="reserved">this</span>.logger.log(<span class="reserved">this</span>.id + <span class="literal">" element is broken"</span>);
            <span class="reserved">return</span>;
        }

        var dx = diffX || 0;
        var dy = diffY || 0;

        var p = YAHOO.util.Dom.getXY( el );

        <span class="reserved">this</span>.initPageX = p[0] - dx;
        <span class="reserved">this</span>.initPageY = p[1] - dy;

        <span class="reserved">this</span>.lastPageX = p[0];
        <span class="reserved">this</span>.lastPageY = p[1];

        <span class="reserved">this</span>.logger.log(<span class="reserved">this</span>.id + <span class="literal">" inital position: "</span> + <span class="reserved">this</span>.initPageX + 
                <span class="literal">", "</span> + <span class="reserved">this</span>.initPageY);


        <span class="reserved">this</span>.setStartPosition(p);
    },

    <span class="comment">/**
     * Add this instance to a group of related drag/drop objects.  All 
     * instances belong to at least one group, and can belong to as many 
     * groups as needed.
     *
     * <span class="attrib">@param</span> sGroup {string} the name of the group
     */</span>
    addToGroup: <span class="reserved">function</span>(sGroup) {
        <span class="reserved">this</span>.groups[sGroup] = true;
        <span class="reserved">this</span>.DDM.regDragDrop(<span class="reserved">this</span>, sGroup);
    },

    <span class="comment">/**
     * Remove's this instance from the supplied interaction group
     * <span class="attrib">@param</span> {string}  sGroup  The group to drop
     */</span>
    removeFromGroup: <span class="reserved">function</span>(sGroup) {
        <span class="reserved">this</span>.logger.log(<span class="literal">"Removing from group: "</span> + sGroup);
        <span class="reserved">if</span> (<span class="reserved">this</span>.groups[sGroup]) {
            delete <span class="reserved">this</span>.groups[sGroup];
        }

        <span class="reserved">this</span>.DDM.removeDDFromGroup(<span class="reserved">this</span>, sGroup);
    },

    <span class="comment">/**
     * Allows you to specify that an element other than the linked element 
     * will be moved with the cursor during a drag
     *
     * <span class="attrib">@param</span> id the id of the element that will be used to initiate the drag
     */</span>
    setDragElId: <span class="reserved">function</span>(id) {
        <span class="reserved">this</span>.dragElId = id;
    },

    <span class="comment">/**
     * Allows you to specify a child of the linked element that should be 
     * used to initiate the drag operation.  An example of this would be if 
     * you have a content div with text and links.  Clicking anywhere in the 
     * content area would normally start the drag operation.  Use this method
     * to specify that an element inside of the content div is the element 
     * that starts the drag operation.
     *
     * <span class="attrib">@param</span> id the id of the element that will be used to initiate the drag
     */</span>
    setHandleElId: <span class="reserved">function</span>(id) {
        <span class="reserved">this</span>.handleElId = id;
        <span class="reserved">this</span>.DDM.regHandle(<span class="reserved">this</span>.id, id);
    },

    <span class="comment">/**
     * Allows you to set an element outside of the linked element as a drag 
     * handle
     */</span>
    setOuterHandleElId: <span class="reserved">function</span>(id) {
        <span class="reserved">this</span>.logger.log(<span class="literal">"Adding outer handle event: "</span> + id);
        YAHOO.util.Event.addListener(id, <span class="literal">"mousedown"</span>, 
                <span class="reserved">this</span>.handleMouseDown, <span class="reserved">this</span>, true);
        <span class="reserved">this</span>.setHandleElId(id);
    },

    <span class="comment">/**
     * Remove all drag and drop hooks for this element
     */</span>
    unreg: <span class="reserved">function</span>() {
        <span class="reserved">this</span>.logger.log(<span class="literal">"DragDrop obj cleanup "</span> + <span class="reserved">this</span>.id);
        YAHOO.util.Event.removeListener(<span class="reserved">this</span>.id, <span class="literal">"mousedown"</span>, 
                <span class="reserved">this</span>.handleMouseDown);
        <span class="reserved">this</span>._domRef = null;
        <span class="reserved">this</span>.DDM._remove(<span class="reserved">this</span>);
    },

    <span class="comment">/**
     * Returns true if this instance is locked, or the drag drop mgr is locked
     * (meaning that all drag/drop is disabled on the page.)
     *
     * <span class="attrib">@return</span> {boolean} true if this obj or all drag/drop is locked, else 
     * false
     */</span>
    isLocked: <span class="reserved">function</span>() {
        <span class="reserved">return</span> (<span class="reserved">this</span>.DDM.isLocked() || <span class="reserved">this</span>.locked);
    },

    <span class="comment">/**
     * Allows you to specify a tag name that should not start a drag operation
     * when clicked.  This is designed to facilitate embedding links within a
     * drag handle that do something other than start the drag.
     * 
     * <span class="attrib">@param</span> {string} tagName the type of element to exclude
     */</span>
    addInvalidHandleType: <span class="reserved">function</span>(tagName) {
        var type = tagName.toUpperCase();
        <span class="reserved">this</span>.invalidHandleTypes[type] = type;
    },

    <span class="comment">/**
     * Lets you to specify an element id for a child of a drag handle
     * that should not initiate a drag
     * <span class="attrib">@param</span> {string} id the element id of the element you wish to ignore
     */</span>
    addInvalidHandleId: <span class="reserved">function</span>(id) {
        <span class="reserved">this</span>.invalidHandleIds[id] = id;
    },


    <span class="comment">/**
     * Lets you specify a css class of elements that will not initiate a drag
     * <span class="attrib">@param</span> {string} cssClass the class of the elements you wish to ignore
     */</span>
    addInvalidHandleClass: <span class="reserved">function</span>(cssClass) {
        <span class="reserved">this</span>.invalidHandleClasses.push(cssClass);
    },

    <span class="comment">/**
     * Unsets an excluded tag name set by addInvalidHandleType
     * 
     * <span class="attrib">@param</span> {string} tagName the type of element to unexclude
     */</span>
    removeInvalidHandleType: <span class="reserved">function</span>(tagName) {
        var type = tagName.toUpperCase();
<span class="comment">        // this.invalidHandleTypes[type] = null;</span>
        delete <span class="reserved">this</span>.invalidHandleTypes[type];
    },
    
    <span class="comment">/**
     * Unsets an invalid handle id
     * <span class="attrib">@param</span> {string} the id of the element to re-enable
     */</span>
    removeInvalidHandleId: <span class="reserved">function</span>(id) {
        delete <span class="reserved">this</span>.invalidHandleIds[id];
    },

    <span class="comment">/**
     * Unsets an invalid css class
     * <span class="attrib">@param</span> {string} the class of the element(s) you wish to re-enable
     */</span>
    removeInvalidHandleClass: <span class="reserved">function</span>(cssClass) {
        <span class="reserved">for</span> (var i=0, len=<span class="reserved">this</span>.invalidHandleClasses.length; i&lt;len; ++i) {
            <span class="reserved">if</span> (<span class="reserved">this</span>.invalidHandleClasses[i] == cssClass) {
                delete <span class="reserved">this</span>.invalidHandleClasses[i];
            }
        }
    },

    <span class="comment">/**
     * Checks the tag exclusion list to see if this click should be ignored
     *
     * <span class="attrib">@param</span> {ygNode} node
     * <span class="attrib">@return</span> {boolean} true if this is a valid tag type, false if not
     */</span>
    isValidHandleChild: <span class="reserved">function</span>(node) {

        var valid = true;
<span class="comment">        // var n = (node.nodeName == "#text") ? node.parentNode : node;</span>
        var nodeName;
        try {
            nodeName = node.nodeName.toUpperCase();
        } catch(e) {
            nodeName = node.nodeName;
        }
        valid = valid &amp;&amp; !<span class="reserved">this</span>.invalidHandleTypes[nodeName];
        valid = valid &amp;&amp; !<span class="reserved">this</span>.invalidHandleIds[node.id];

        <span class="reserved">for</span> (var i=0, len=<span class="reserved">this</span>.invalidHandleClasses.length; valid &amp;&amp; i&lt;len; ++i) {
            valid = !YAHOO.util.Dom.hasClass(node, <span class="reserved">this</span>.invalidHandleClasses[i]);
        }

        <span class="reserved">this</span>.logger.log(<span class="literal">"Valid handle? ... "</span> + valid);

        <span class="reserved">return</span> valid;

    },

    <span class="comment">/**
     * By default, the element can be dragged any place on the screen.  Use 
     * this method to limit the horizontal travel of the element.  Pass in 
     * 0,0 for the parameters if you want to lock the drag to the y axis.
     *
     * <span class="attrib">@param</span> {int} iLeft the number of pixels the element can move to the left
     * <span class="attrib">@param</span> {int} iRight the number of pixels the element can move to the 
     * right
     * <span class="attrib">@param</span> {int} iTickSize optional parameter for specifying that the 
     * element
     * should move iTickSize pixels at a time.
     */</span>
    setXConstraint: <span class="reserved">function</span>(iLeft, iRight, iTickSize) {
        <span class="reserved">this</span>.leftConstraint = iLeft;
        <span class="reserved">this</span>.rightConstraint = iRight;

        <span class="reserved">this</span>.minX = <span class="reserved">this</span>.initPageX - iLeft;
        <span class="reserved">this</span>.maxX = <span class="reserved">this</span>.initPageX + iRight;
        <span class="reserved">if</span> (iTickSize) { <span class="reserved">this</span>.setXTicks(<span class="reserved">this</span>.initPageX, iTickSize); }

        <span class="reserved">this</span>.constrainX = true;
        <span class="reserved">this</span>.logger.log(<span class="literal">"initPageX:"</span> + <span class="reserved">this</span>.initPageX + <span class="literal">" minX:"</span> + <span class="reserved">this</span>.minX + 
                <span class="literal">" maxX:"</span> + <span class="reserved">this</span>.maxX);
    },

    <span class="comment">/**
     * Clears any constraints applied to this instance.  Also clears ticks
     * since they can't exist independent of a constraint at this time.
     */</span>
    clearConstraints: <span class="reserved">function</span>() {
        <span class="reserved">this</span>.logger.log(<span class="literal">"Clearing constraints"</span>);
        <span class="reserved">this</span>.constrainX = false;
        <span class="reserved">this</span>.constrainY = false;
        <span class="reserved">this</span>.clearTicks();
    },

    <span class="comment">/**
     * Clears any tick interval defined for this instance
     */</span>
    clearTicks: <span class="reserved">function</span>() {
        <span class="reserved">this</span>.logger.log(<span class="literal">"Clearing ticks"</span>);
        <span class="reserved">this</span>.xTicks = null;
        <span class="reserved">this</span>.yTicks = null;
        <span class="reserved">this</span>.xTickSize = 0;
        <span class="reserved">this</span>.yTickSize = 0;
    },

    <span class="comment">/**
     * By default, the element can be dragged any place on the screen.  Set 
     * this to limit the vertical travel of the element.  Pass in 0,0 for the
     * parameters if you want to lock the drag to the x axis.
     *
     * <span class="attrib">@param</span> {int} iUp the number of pixels the element can move up
     * <span class="attrib">@param</span> {int} iDown the number of pixels the element can move down
     * <span class="attrib">@param</span> {int} iTickSize optional parameter for specifying that the 
     * element should move iTickSize pixels at a time.
     */</span>
    setYConstraint: <span class="reserved">function</span>(iUp, iDown, iTickSize) {
        <span class="reserved">this</span>.logger.log(<span class="literal">"setYConstraint: "</span> + iUp + <span class="literal">","</span> + iDown + <span class="literal">","</span> + iTickSize);
        <span class="reserved">this</span>.topConstraint = iUp;
        <span class="reserved">this</span>.bottomConstraint = iDown;

        <span class="reserved">this</span>.minY = <span class="reserved">this</span>.initPageY - iUp;
        <span class="reserved">this</span>.maxY = <span class="reserved">this</span>.initPageY + iDown;
        <span class="reserved">if</span> (iTickSize) { <span class="reserved">this</span>.setYTicks(<span class="reserved">this</span>.initPageY, iTickSize); }

        <span class="reserved">this</span>.constrainY = true;
        
        <span class="reserved">this</span>.logger.log(<span class="literal">"initPageY:"</span> + <span class="reserved">this</span>.initPageY + <span class="literal">" minY:"</span> + <span class="reserved">this</span>.minY + 
                <span class="literal">" maxY:"</span> + <span class="reserved">this</span>.maxY);
    },

    <span class="comment">/**
     * resetConstraints must be called if you manually reposition a dd element.
     * <span class="attrib">@param</span> {boolean} maintainOffset
     */</span>
    resetConstraints: <span class="reserved">function</span>() {

        <span class="reserved">this</span>.logger.log(<span class="literal">"resetConstraints"</span>);
<span class="comment">
        // Maintain offsets if necessary</span>
        <span class="reserved">if</span> (<span class="reserved">this</span>.initPageX || <span class="reserved">this</span>.initPageX === 0) {
            <span class="reserved">this</span>.logger.log(<span class="literal">"init pagexy: "</span> + <span class="reserved">this</span>.initPageX + <span class="literal">", "</span> + 
                               <span class="reserved">this</span>.initPageY);
            <span class="reserved">this</span>.logger.log(<span class="literal">"last pagexy: "</span> + <span class="reserved">this</span>.lastPageX + <span class="literal">", "</span> + 
                               <span class="reserved">this</span>.lastPageY);
<span class="comment">            // figure out how much this thing has moved</span>
            var dx = (<span class="reserved">this</span>.maintainOffset) ? <span class="reserved">this</span>.lastPageX - <span class="reserved">this</span>.initPageX : 0;
            var dy = (<span class="reserved">this</span>.maintainOffset) ? <span class="reserved">this</span>.lastPageY - <span class="reserved">this</span>.initPageY : 0;

            <span class="reserved">this</span>.setInitPosition(dx, dy);
<span class="comment">
        // This is the first time we have detected the element's position</span>
        } <span class="reserved">else</span> {
            <span class="reserved">this</span>.setInitPosition();
        }

        <span class="reserved">if</span> (<span class="reserved">this</span>.constrainX) {
            <span class="reserved">this</span>.setXConstraint( <span class="reserved">this</span>.leftConstraint, 
                                 <span class="reserved">this</span>.rightConstraint, 
                                 <span class="reserved">this</span>.xTickSize        );
        }

        <span class="reserved">if</span> (<span class="reserved">this</span>.constrainY) {
            <span class="reserved">this</span>.setYConstraint( <span class="reserved">this</span>.topConstraint, 
                                 <span class="reserved">this</span>.bottomConstraint, 
                                 <span class="reserved">this</span>.yTickSize         );
        }
    },

    <span class="comment">/**
     * toString method
     * <span class="attrib">@return</span> {string} string representation of the dd obj
     */</span>
    toString: <span class="reserved">function</span>() {
        <span class="reserved">return</span> (<span class="literal">"DragDrop "</span> + <span class="reserved">this</span>.id);
    }

};

</pre>
			</div>
		
	</div>
</div>


<div id="footer">
    <hr />
    Copyright &copy; 2004 - 2006 Yahoo! Inc. All rights reserved.
</div>


</body>
</html>
